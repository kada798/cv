<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Notes de développement – 2025.12.02</title>
</head>
<body>

  <h3>2025.12.02</h3>

  <p>
// Ajustement de l’espacement entre les fragments et de la largeur d’affichage pour optimiser la mise en page.<br>
/// Nouveau problème : à l’ouverture du puzzle, l’écran reste noir et l’image ne se charge pas ; en quittant puis en rouvrant une deuxième fois, l’image apparaît correctement.<br>
///
  </p>

  <h4>Dans la partie <code>class Puzzle extends Phaser.Scene</code></h4>

  <p>
    <strong>Code d’origine :</strong><br>
    <code>displayW</code> contrôlait l’espacement. La valeur 46px correspondait à la taille réelle du fragment visuel.  
    Les deux valeurs (46px et 80px) garantissaient un alignement propre du puzzle tout en laissant un espace visuel.  
    Cependant, avec <code>displayW = 80</code>, l’écart est trop grand :  
    largeur réelle ≈ 46px → différence = 80 − 46 = 34px d’espace perdu de chaque côté du fragment.
  </





2025.12.02

// 调整了碎片间距和显示宽度以优化布局
/// 新问题：打开拼图时，显示时黑屏，加载不出图片；退出第二次点击时可以看到图片。
///


在  class Puzzle extends Phaser.Scene部分
源代码：displayW 控制空间分为，46px 是实际内容。两者一起确保了拼图整齐排列且留有视觉呼吸空间。但display为80，displayW = 80px（逻辑位置间隔）实际图像宽度 ≈ 46px
差额 = 80 - 46 = 34px 的浪费空间（每个切片两侧）

      const grid = 15;
      const spacing = 4;
      const displayW = 80;
      const displayH = 120;

      const src = this.textures.get('qingming_main').getSourceImage();
      this.imgW = src.width;
      this.imgH = src.height;
      this.sliceW = Math.floor(this.imgW / grid);

订正：
const grid = 15;
const spacing = 4;
const displayH = 120;
const scale = displayH / this.imgH;  // 0.358
const scaledSliceW = Math.floor(this.sliceW * scale);  // 自动 = 46px
const displayW = scaledSliceW + spacing;  // 50px（图像 + 空隙）


