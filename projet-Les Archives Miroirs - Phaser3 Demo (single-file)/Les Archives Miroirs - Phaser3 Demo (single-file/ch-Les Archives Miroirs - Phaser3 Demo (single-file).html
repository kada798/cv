<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Les Archives Miroirs - Demo</title>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#111; color:#eee; }
    #game-container { width:100%; height:100vh; }
    .ui-panel { position: absolute; left: 10px; top: 10px; background: rgba(0,0,0,0.6); padding:10px; border-radius:6px; }
    .choice-btn { background: #222; border:1px solid #666; color:#fff; padding:6px 10px; margin:6px; cursor:pointer; border-radius:4px; }
    .choice-btn:hover { background:#333; }
  </style>
</head>
<body>
  <div id="game-container"></div>

  <!-- Phaser 3 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  // -- Minimal single-file demo for "Les Archives Miroirs" --

  const DIALOGUES = {
    intro: [
      "Année 2042 — Les musées ont numérisé tout le patrimoine.",
      "Vous êtes archiviste. Des traces d'anomalies apparaissent dans les Archives Miroirs.",
      "Votre tâche : explorer, décrypter, décider."
    ],
    archiveDescriptions: [
      {id:'qingming', title:'Le long de la rivière (fragment)', text:'Fragment numérisé — possible interpolation algorithmique détectée.'},
      {id:'wubian', title:'Temple Wubian (scan)', text:'Scan partiel : zones reconstruites par IA.'},
      {id:'manuscrit', title:'Manuscrit ancien', text:'Texte corrompu, symboles manquants.'}
    ]
  };

  // Global game state
  const gameState = { choices: [] };

  class BootScene extends Phaser.Scene {
    constructor(){ super('Boot'); }
    preload(){ }
    create(){ this.scene.start('Intro'); }
  }

  class Intro extends Phaser.Scene {
    constructor(){ super('Intro'); }
    create(){
      const w = this.scale.width, h = this.scale.height;
      this.cameras.main.setBackgroundColor('#080808');
      this.add.text(w/2, h/3, 'Les Archives Miroirs', {fontSize: '32px', color:'#fff'}).setOrigin(0.5);
      const lines = DIALOGUES.intro;
      this.lineIndex = 0;
      this.txt = this.add.text(w/2, h/2, lines[0], {fontSize:'20px', color:'#ddd', wordWrap:{width:w*0.8}}).setOrigin(0.5);
      this.nextButton = this.add.text(w/2, h*0.75, 'Continuer →', {fontSize:'18px', backgroundColor:'#222', padding:6}).setOrigin(0.5).setInteractive();
      this.nextButton.on('pointerup', ()=>{
        this.lineIndex++;
        if(this.lineIndex < lines.length){ this.txt.setText(lines[this.lineIndex]); }
        else { this.scene.start('ArchiveRoom'); }
      });
    }
  }

  class ArchiveRoom extends Phaser.Scene {
    constructor(){ super('ArchiveRoom'); }
    create(){
      const w = this.scale.width, h = this.scale.height;
      this.cameras.main.setBackgroundColor('#06121a');

      this.add.text(20,20, 'Salle des Archives — cliquez sur un objet', {fontSize:'18px'});

      // create simple 'objects' as rectangles
      this.objectsGroup = this.add.group();
      const baseX = 120, baseY = 120, gap = 240;
      DIALOGUES.archiveDescriptions.forEach((item, i)=>{
        const container = this.add.container(baseX + i*gap, baseY);
        const rect = this.add.rectangle(0,0,180,120, 0x3a6f86).setStrokeStyle(2,0xffffff,0.06);
        const label = this.add.text(0,60,item.title, {fontSize:'14px'}).setOrigin(0.5,0);
        container.add([rect,label]);
        container.setSize(180,120);
        container.setInteractive(new Phaser.Geom.Rectangle(-90,-60,180,120), Phaser.Geom.Rectangle.Contains);
        container.itemData = item;
        container.on('pointerup', ()=> this.openArchive(container.itemData));
        this.objectsGroup.add(container);
      });

      // UI: Puzzle button & status
      this.puzzleBtn = this.add.text(w-160, 20, 'Décryptage (puzzle)', {fontSize:'16px', backgroundColor:'#222', padding:8}).setInteractive();
      this.puzzleBtn.on('pointerup', ()=> this.scene.launch('PuzzleScene'));

      // display choices made
      this.choiceText = this.add.text(w-360, 24, 'Choix: —', {fontSize:'14px'}).setOrigin(0,0);
    }
    openArchive(item){
      const w = this.scale.width, h = this.scale.height;
      // simple modal
      const bg = this.add.rectangle(w/2,h/2, w*0.8, h*0.6, 0x000000, 0.85);
      const box = this.add.container(0,0);
      box.add(bg);
      const title = this.add.text(w/2, h/2 - 160, item.title, {fontSize:'22px'}).setOrigin(0.5);
      const text = this.add.text(w/2 - (w*0.8)/2 + 20, h/2 - 120, item.text, {fontSize:'16px', wordWrap:{width:w*0.8-40}});
      const btnKeep = this.add.text(w/2 - 130, h/2 + 160, '保留', {fontSize:'16px', backgroundColor:'#1b5e20', padding:8}).setInteractive();
      const btnClean = this.add.text(w/2 - 10, h/2 + 160, '清理', {fontSize:'16px', backgroundColor:'#b57f00', padding:8}).setInteractive();
      const btnDel = this.add.text(w/2 + 110, h/2 + 160, '删除', {fontSize:'16px', backgroundColor:'#7b0000', padding:8}).setInteractive();
      box.add([title,text,btnKeep,btnClean,btnDel]);

      const closeAll = ()=>{ box.removeAll(true); box.destroy(true); }
      btnKeep.on('pointerup', ()=>{ gameState.choices.push({id:item.id, action:'keep'}); this.updateChoices(); closeAll(); });
      btnClean.on('pointerup', ()=>{ gameState.choices.push({id:item.id, action:'clean'}); this.updateChoices(); closeAll(); });
      btnDel.on('pointerup', ()=>{ gameState.choices.push({id:item.id, action:'delete'}); this.updateChoices(); closeAll(); });
    }
    updateChoices(){ this.choiceText.setText('Choix: ' + JSON.stringify(gameState.choices.map(c=>c.action))); if(gameState.choices.length>=3){ this.scene.start('Ending'); } }
  }

  class PuzzleScene extends Phaser.Scene{
    constructor(){ super('PuzzleScene'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#051220');
      this.add.text(20,20,'Puzzle: reconstruire le fragment', {fontSize:'18px'});

      // Simple 2x2 tile shuffle puzzle using colored tiles and numbers
      this.tiles = [];
      const sx = w/2-80, sy = h/2-80, size=80;
      this.solution = [1,2,3,4];
      this.stateArr = Phaser.Utils.Array.Shuffle([1,2,3,4]);

      for(let i=0;i<4;i++){
        const tx = sx + (i%2)*size*1.1, ty = sy + Math.floor(i/2)*size*1.1;
        const tile = this.add.rectangle(tx,ty,size,size, 0x4b7c9b).setStrokeStyle(2,0x000000);
        const num = this.add.text(tx,ty, ''+this.stateArr[i], {fontSize:'28px'}).setOrigin(0.5);
        tile.index = i; tile.value = this.stateArr[i]; tile.numTxt = num;
        tile.setInteractive();
        tile.on('pointerup', ()=> this.onTileClick(tile));
        this.tiles.push(tile);
      }

      this.selected = null;
      this.statusText = this.add.text(w/2, sy + 220, '点击拼出正确顺序 1 2 3 4', {fontSize:'16px'}).setOrigin(0.5);
      this.add.text(w-160,20,'关闭', {fontSize:'14px', backgroundColor:'#222', padding:6}).setInteractive().on('pointerup', ()=> this.scene.stop());
    }
    onTileClick(tile){
      if(!this.selected){ this.selected = tile; tile.setStrokeStyle(4,0xffff00); }
      else{ // swap values
        const a = this.selected, b = tile;
        const tmp = a.value; a.value = b.value; b.value = tmp;
        a.numTxt.setText(''+a.value); b.numTxt.setText(''+b.value);
        a.setStrokeStyle(2,0x000000); this.selected = null;
        if(this.checkSolved()){ this.statusText.setText('Puzzle résolu ! (+clean credit)'); gameState.choices.push({id:'puzzle', action:'puzzle_solved'}); }
      }
    }
    checkSolved(){
      return this.tiles.map(t=>t.value).join(',') === this.solution.join(',');
    }
  }

  class Ending extends Phaser.Scene{
    constructor(){ super('Ending'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#030308');
      this.add.text(20,20,'结局选择', {fontSize:'18px'});
      this.add.text(w/2, h/3, '现在你必须对系统做出最终决定：', {fontSize:'20px'}).setOrigin(0.5);

      const keepBtn = this.add.text(w/2 - 220, h/2, '维持系统', {fontSize:'16px', backgroundColor:'#164', padding:8}).setInteractive().setOrigin(0.5);
      const cleanBtn = this.add.text(w/2, h/2, '清理数据', {fontSize:'16px', backgroundColor:'#b55', padding:8}).setInteractive().setOrigin(0.5);
      const shutBtn  = this.add.text(w/2 + 220, h/2, '关闭系统', {fontSize:'16px', backgroundColor:'#800', padding:8}).setInteractive().setOrigin(0.5);

      keepBtn.on('pointerup', ()=> this.showFinal('keep'));
      cleanBtn.on('pointerup', ()=> this.showFinal('clean'));
      shutBtn.on('pointerup', ()=> this.showFinal('shut'));

      this.finalText = this.add.text(w/2, h*0.75, '', {fontSize:'18px', wordWrap:{width:w*0.8}}).setOrigin(0.5);
    }
    showFinal(choice){
      let txt='';
      if(choice==='keep') txt = '你选择维持系统。记忆被完美化 — 历史变得连贯但逐渐失去裂缝。';
      if(choice==='clean') txt = '你选择清理数据。人工与真实的痕迹被保留，虚构被去除。';
      if(choice==='shut')  txt = '你选择关闭系统。记忆的空白回归——人类再次拥有遗忘的权利。';
      this.finalText.setText(txt);
      gameState.final = choice;
      // simple summary log in console
      console.log('Game state', gameState);
    }
  }

  const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: 1000,
    height: 700,
    backgroundColor: '#111',
    scene: [BootScene, Intro, ArchiveRoom, PuzzleScene, Ending]
  };

  const game = new Phaser.Game(config);

  </script>
</body>
</html>
