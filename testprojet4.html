<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Les Archives Miroirs - Démo (FR, Qingming seulement)</title>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#0b0b0e; color:#eee; }
    #game-container { width:100%; height:100vh; }
    .choice-btn { background: #222; border:1px solid #666; color:#fff; padding:6px 10px; margin:6px; cursor:pointer; border-radius:4px; }
    .choice-btn:hover { background:#333; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  /* Version simplifiée :
     - Un seul objet : « Le long de la rivière pendant la fête de Qingming »
     - Un puzzle de 15×1 pour restaurer le rouleau
     - Une scène de métadonnées erronées à corriger
     - Un choix moral final
  */

  const DIALOGUES = {
    intro: [
      "Année 2042 — Les archives numériques montrent des anomalies.",
      "Vous êtes archiviste numérique chargé d'examiner un fragment unique :",
      "« Le long de la rivière pendant la fête de Qingming » — reconstruction IA instable."
    ],
    qingming: {
      id:'qingming',
      title:"« Le long de la rivière pendant la fête de Qingming » ",
      text:"Scan haute définition. Des segments ont été réécrits automatiquement par l'IA. Des incohérences picturales sont détectées."
    }
  };

  const gameState = { choices: [], final: null };

  class Boot extends Phaser.Scene{ constructor(){ super('Boot'); }preload(){
    // 加载清明上河图主图（用于缩略图）
    this.load.image('qingming_thumb', 'assets/qingming_thumb.png');
    // 主图，用于 Puzzle 横向拼图
    this.load.image('qingming_main', 'assets/qingming_main.png');
  } create(){ this.scene.start('Intro'); } }

  class Intro extends Phaser.Scene{
    constructor(){ super('Intro'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#071018');
      this.add.text(w/2, h/3, 'Les Archives Miroirs', {fontSize:'36px', color:'#fff'}).setOrigin(0.5);
      const lines=DIALOGUES.intro;
      let idx=0;
      const txt=this.add.text(w/2,h/2,lines[0],{fontSize:'20px',color:'#ddd',wordWrap:{width:w*0.8}}).setOrigin(0.5);
      const next=this.add.text(w/2,h*0.75,'Continuer →',{fontSize:'18px',backgroundColor:'#222',padding:8}).setOrigin(0.5).setInteractive();
      next.on('pointerup',()=>{
        idx++;
        if(idx<lines.length) txt.setText(lines[idx]);
        else this.scene.start('ArchiveRoom');
      });
    }
  }

  class ArchiveRoom extends Phaser.Scene{
    constructor(){ super('ArchiveRoom'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#07121a');
      this.add.text(20,20,'Salle des archives : Fragment Qingming', {fontSize:'18px'});

      const item = DIALOGUES.qingming;
      const container = this.add.container(w/2, h/2 - 40);
      // 替换为缩略图显示
      const img = this.add.image(0, -10, 'qingming_thumb').setOrigin(0.5,0.5);
      img.setScale(0.32); // 根据缩略图大小调整
      container.add(img);

      const label = this.add.text(0,100,item.title,{fontSize:'16px'}).setOrigin(0.5);
      container.add(label);

      // 调整 container 交互区域，保持原有交互逻辑
      container.setSize(img.displayWidth, img.displayHeight + 40);
      container.setInteractive(
        new Phaser.Geom.Rectangle(-img.displayWidth/2, -img.displayHeight/2, img.displayWidth, img.displayHeight+40),
        Phaser.Geom.Rectangle.Contains
      );

      // Background rectangle inside container
      const rect = this.add.rectangle(0, 0, 100, 10, 0xFFFFFF).setOrigin(0.5);
      container.add(rect);

      container.setSize(320,200);
      container.setInteractive(new Phaser.Geom.Rectangle(-160,-100,320,200), Phaser.Geom.Rectangle.Contains);
      container.on('pointerup',()=> this.openArchive(item));
      container.on('pointerover',()=> rect.setFillStyle(0x3f7b8d));
      container.on('pointerout',()=> rect.setFillStyle(0x325b6e));
      container.on('pointerover',()=> img.setTint(0xaaaaaa));
      container.on('pointerout',()=> img.clearTint());


      this.add.text(20,h-60,'Décryptage : Puzzle 15×1 →',{fontSize:'16px',backgroundColor:'#222',padding:8}).setInteractive().on('pointerup',()=>this.scene.launch('Puzzle'));

      this.choiceText = this.add.text(w-320,20,'Choix : —',{fontSize:'14px'});
      this.add.text(60,h-80, "MetadataScene", {
    fontSize: "24px",
    color: "#0077ff"
})
.setInteractive()
.on('pointerdown', () => {
    this.scene.start("MetadataScene");
});

    }

    openArchive(item){
      const w=this.scale.width, h=this.scale.height;
      const bg=this.add.rectangle(w/2,h/2, w*0.8, h*0.6, 0x000000,0.92);
      const box=this.add.container(0,0,[bg]);
      const title=this.add.text(w/2,h/2-170,item.title,{fontSize:'22px'}).setOrigin(0.5);
      const text=this.add.text(w/2-(w*0.8)/2+24,h/2-120,item.text,{fontSize:'16px',wordWrap:{width:w*0.8-48}});
      const b1=this.add.text(w/2-160,h/2+160,'GARDER',{fontSize:'16px',backgroundColor:'#2e7d32',padding:8}).setInteractive();
      const b2=this.add.text(w/2,h/2+160,'NETTOYER',{fontSize:'16px',backgroundColor:'#f0a000',padding:8}).setInteractive();
      const b3=this.add.text(w/2+160,h/2+160,'SUPPRIMER',{fontSize:'16px',backgroundColor:'#b71c1c',padding:8}).setInteractive();
      box.add([title,text,b1,b2,b3]);
      const close=()=>{ box.destroy(true); };
      const act=(a)=>{ gameState.choices.push({id:item.id,action:a}); this.updateChoices(); close(); };
      b1.on('pointerup',()=>act('garder'));
      b2.on('pointerup',()=>act('nettoyer'));
      b3.on('pointerup',()=>act('supprimer'));
    }

    updateChoices(){
      this.choiceText.setText('Choix : '+gameState.choices.map(c=>c.action).join(', '));
      if(gameState.choices.length>=1){ this.scene.start('Ending'); }
    }
  }

  class Puzzle extends Phaser.Scene {
    constructor() { super('Puzzle'); }

    create() {
      const w = this.scale.width;
      const h = this.scale.height;

      this.cameras.main.setBackgroundColor('#06121b');
      this.add.text(20, 20, 'Puzzle Qingming (15 × 1)', { fontSize: '18px' });//image 1920*335,1920/15=128,128*335sliceW

      const grid = 15;
      const spacing = 4;
      const displayH = 120;        

      const scale = displayH / this.imgH;  // 0.358
      const scaledSliceW = Math.floor(this.sliceW * scale);  // 自动 = 46px
      const displayW = scaledSliceW + spacing;  // 50px（图像 + 空隙）

      const src = this.textures.get('qingming_main').getSourceImage();
      this.imgW = src.width;
      this.imgH = src.height;
      this.sliceW = Math.floor(this.imgW / grid);

      this.solution = [];
      for (let i = 1; i <= grid; i++) this.solution.push(i);
      this.state = Phaser.Utils.Array.Shuffle(this.solution.slice());

      const totalW = grid * displayW + (grid - 1) * spacing;
      const startX = w / 2 - totalW / 2 + displayW / 2;
      const y = h / 2;

      this.slices = [];
      this.selected = null;

      for (let i = 0; i < grid; i++) {
        const curVal = this.state[i];
        const x = startX + i * (displayW + spacing);

        const img = this.add.image(x, y, 'qingming_main')
          .setOrigin(0.5)
        // 自动按高度缩小，让切片保持原比例
        const scale = displayH / this.imgH;
        img.setScale(scale);

        img.currentValue = curVal;

        img.setCrop(
          (curVal - 1) * this.sliceW,
          0,
          this.sliceW,
          this.imgH
        );

        // const border = this.add.rectangle( x, y, displayW, displayH） 

        const scaledW = this.sliceW * scale;
        const scaledH = this.imgH * scale;
        const border = this.add.rectangle(
          x, y, scaledW, scaledH
        ).setStrokeStyle(0, 0xffffff)
         .setOrigin(0.5);
               


        img.border = border;
        

        img.setInteractive();
        img.on('pointerup', () => this.onSliceClicked(img));

        this.slices.push(img);
      }

      this.status = this.add.text(
        w / 2,
        y + displayH + 50,
        'Réorganisez le long rouleau...',
        { fontSize: '16px' }
      ).setOrigin(0.5);

      this.add.text(w - 120, 20, 'FERMER', {
        fontSize: '14px',
        backgroundColor: '#222',
        padding: 6
      })
        .setInteractive()
        .on('pointerup', () => this.scene.stop());

      // 摄像机边界，保证能拖动查看完整拼图
      this.cameras.main.setBounds(0, 0, totalW, this.imgH);
      this.input.on('pointermove', (pointer) => {
        if (pointer.isDown) {
          this.cameras.main.scrollX -= (pointer.x - pointer.prevPosition.x);
        }
      });
    }
  
    onSliceClicked(img) {
      if (!this.selected) {
        this.selected = img;
        img.border.setStrokeStyle(3, 0xffe082);
        return;
      }

      if (img === this.selected) {
        img.border.setStrokeStyle(0);
        this.selected = null;
        return;
      }

      const a = this.selected;
      const b = img;

      const tmp = a.currentValue;
      a.currentValue = b.currentValue;
      b.currentValue = tmp;

      a.setCrop(
        (a.currentValue - 1) * this.sliceW,
        0,
        this.sliceW,
        this.imgH
      );

      b.setCrop(
        (b.currentValue - 1) * this.sliceW,
        0,
        this.sliceW,
        this.imgH
      );

      a.border.setStrokeStyle(0);
      this.selected = null;

      if (this.isSolved()) {
        this.status.setText('Puzzle résolu ! Le rouleau est restauré.');
        gameState.choices.push({ id: 'puzzle_qingming', action: 'resolu' });
      }
    }

    isSolved() {
      for (let i = 0; i < this.solution.length; i++) {
        if (this.slices[i].currentValue !== this.solution[i]) return false;
      }
      return true;
    }
  }
  
  class ScrollableQingming extends Phaser.Scene {
    constructor() { super('ScrollableQingming'); }

    preload() {
      // 已在主场景 preload 过的可省略
      // this.load.image('qingming_main', 'assets/qingming_main.png');
    }

    create() {
      this.cameras.main.setBackgroundColor('#000');

      const w = this.scale.width;
      const h = this.scale.height;

      // 获取主图尺寸
      const src = this.textures.get('qingming_main').getSourceImage();
      const imgW = src.width;
      const imgH = src.height;

      // 居中显示，但保持原始尺寸（长卷更真实）
      this.roll = this.add.image(0, h / 2, 'qingming_main')
        .setOrigin(0, 0.5);

      // 开启拖拽
      this.input.setDraggable(this.roll);

      this.roll.on('drag', (pointer, dragX) => {
        // 水平拖动
        this.roll.x = dragX;

        // 限制左右边界，不让图像拖出太多
        if (this.roll.x > 0) this.roll.x = 0;  // 左侧极限
        if (this.roll.x < w - imgW) this.roll.x = w - imgW; // 右侧极限
      });

      // 让图像可被拖动
      this.roll.setInteractive();

      // 提示文本
      this.add.text(w / 2, 30, '▲ Faites glisser horizontalement pour parcourir le rouleau ▲', {
        fontSize: '16px',
        color: '#ffffff'
      }).setOrigin(0.5);

      // 返回按钮
      this.add.text(w - 120, 20, 'FERMER', {
        fontSize: '14px',
        backgroundColor: '#222',
        padding: 6
      })
        .setInteractive()
        .on('pointerup', () => this.scene.stop());
    }
  }

  class MetadataScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MetadataScene' });
    }

    create() {
        // 背景
        this.cameras.main.setBackgroundColor('#ffffff');


        // 错误元数据
        const lines = [
                { 
        text: "1. Ce rouleau a été peint en l’an 800, durant la dynastie Song du Nord.", 
        wrong: true  // 实创作于12世纪
    },
    { 
        text: "2. L’œuvre utilise une technique de coloration typique de la dynastie Ming.", 
        wrong: true  // 明代设色技法不是张择端版本
    },
    { 
        text: "3. « Le long de la rivière pendant la fête de Qingming » représente la capitale Bianjing (aujourd’hui Kaifeng) en pleine effervescence durant la fête de Qingming.", 
        wrong: false // 这是正确描述
    },
    { 
        text: "4. Ce rouleau fait partie des dix peintures les plus célèbres de l’histoire chinoise.", 
        wrong: false  // 说法流行但不属于官方“十大”
    },
    { 
        text: "5. Le début du rouleau montre les faubourgs, la partie centrale se concentre sur le pont en arc, et la fin décrit les rues animées de la ville.", 
        wrong: false  //  正确描述
    },
    { 
        text: "6. Le rouleau montre plus de cinq types de moyens de transport.", 
        wrong: false  // 正确描述
    },
    { 
        text: "7. Le rouleau représente moins de dix catégories sociales parmi les personnages.", 
        wrong: true  // 实际人物身份种类非常多
    }
];


        this.selected = 0;
        this.totalWrong = lines.filter(l => l.wrong).length;

        const startY = 120;
        const gap = 50;

        lines.forEach((line, i) => {
            let textObj = this.add.text(60, startY + i * gap, line.text, {
                fontSize: '20px',
                color: '#000'
            }).setInteractive();

            // 点击事件
            textObj.on('pointerdown', () => {
                if (line.wrong) {
                    textObj.setColor('#d60000'); // 红色表示选对了（错误句子）
                } else {
                    textObj.setColor('#00a000'); // 绿色表示误选
                }

                textObj.disableInteractive();
                this.selected++;

                if (this.selected === this.totalWrong) {
                    this.showResult();
                }
            });
        });

        // 返回按钮
        this.add.text(20, 20, "← Retour", {
            fontSize: '24px',
            color: '#0077ff'
        })
        .setInteractive()
        .on('pointerdown', () => {
            this.scene.start("Puzzle");
        });
    }

    showResult() {
        this.add.text(60, 380, "Terminé ! Vous avez identifié toutes les métadonnées erronées.", {
            fontSize: '22px',
            color: '#222'
        });
    }
}

  class Ending extends Phaser.Scene{
    constructor(){ super('Ending'); }
    create(){
      const w=this.scale.width,h=this.scale.height;
      this.cameras.main.setBackgroundColor('#03040a');
      this.add.text(w/2,h/3,'Décision finale',{fontSize:'24px'}).setOrigin(0.5);
      const b1=this.add.text(w/2-240,h/2,'MAINTENIR',{fontSize:'16px',backgroundColor:'#1565c0',padding:8}).setInteractive().setOrigin(0.5);
      const b2=this.add.text(w/2,h/2,'NETTOYER',{fontSize:'16px',backgroundColor:'#2e7d32',padding:8}).setInteractive().setOrigin(0.5);
      const b3=this.add.text(w/2+240,h/2,'ARRÊTER',{fontSize:'16px',backgroundColor:'#c62828',padding:8}).setInteractive().setOrigin(0.5);
      this.final=this.add.text(w/2,h*0.75,'',{fontSize:'18px',wordWrap:{width:w*0.8}}).setOrigin(0.5);
      b1.on('pointerup',()=>this.end('maintenir'));
      b2.on('pointerup',()=>this.end('nettoyer'));
      b3.on('pointerup',()=>this.end('arreter'));
    }

    end(c){
      const map={
        maintenir:"Vous maintenez le système. Mémoire parfaite, ambiguïtés effacées.",
        nettoyer:"Vous nettoyez les données. Les reconstructions IA sont supprimées.",
        arreter:"Vous arrêtez le système. Le droit à l'oubli revient." };
      this.final.setText(map[c]);
      gameState.final=c;
    }
  }

  const config={ type:Phaser.AUTO, parent:'game-container', width:1100, height:760, scene:[Boot,Intro,ArchiveRoom,Puzzle,MetadataScene,Ending] };
  new Phaser.Game(config);
  
  </script>
</body>
</html>
