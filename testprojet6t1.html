<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Les Archives Miroirs - Démo (FR, Qingming seulement)</title>
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; background:#0b0b0e; color:#eee; }
    #game-container { width:100%; height:100vh; }
    .choice-btn { background: #222; border:1px solid #666; color:#fff; padding:6px 10px; margin:6px; cursor:pointer; border-radius:4px; }
    .choice-btn:hover { background:#333; }
  </style>
</head>
<body>
  <div id="game-container"></div>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  /* Version simplifiée :
     - Un seul objet : « Le long de la rivière pendant la fête de Qingming »
     - Un puzzle de 15×1 pour restaurer le rouleau
     - Une scène de métadonnées erronées à corriger
     - Un choix moral final
  */

  const DIALOGUES = {
    intro: [
      "Année 2042 — Une restauration par IA présente des anomalies.\nVous êtes archiviste numérique, chargé d’analyser « Le long de la rivière pendant la fête de Qingming ».\nDes erreurs visuelles et historiques ont été introduites par l’IA.\nRésolvez des mini-jeux pour identifier et éliminer chaque anomalie.\nStabilisez l’œuvre avant que les archives ne se dégradent définitivement."    ],
    qingming: {
      id:'qingming',
      title:"« Le long de la rivière pendant la fête de Qingming » ",
      text:"Scan haute définition. Des segments ont été réécrits automatiquement par l'IA. Des incohérences picturales sont détectées."
    }
  };

  const gameState = { choices: [], final: null };

  class Boot extends Phaser.Scene{ constructor(){ super('Boot'); }preload(){
    // 加载清明上河图主图（用于缩略图）
    this.load.image('qingming_thumb', 'assets/qingming_thumb.png');
    // 主图，用于 Puzzle 横向拼图
    this.load.image('qingming_main', 'assets/qingming_main.png');
  } create(){ this.scene.start('Intro'); } }

  class Intro extends Phaser.Scene{
    constructor(){ super('Intro'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#071018');
      this.add.text(w/2, h/3, 'Les Archives Miroirs', {fontSize:'36px', color:'#fff'}).setOrigin(0.5);
      const lines=DIALOGUES.intro;
      let idx=0;
      const txt=this.add.text(w/2,h/2,lines[0],{fontSize:'20px',color:'#ddd',wordWrap:{width:w*0.8}}).setOrigin(0.5);
      const next=this.add.text(w/2,h*0.75,'Continuer →',{fontSize:'18px',backgroundColor:'#222',padding:8}).setOrigin(0.5).setInteractive();
      next.on('pointerup',()=>{
        idx++;
        if(idx<lines.length) txt.setText(lines[idx]);
        else this.scene.start('ArchiveRoom');
      });
    }
  }

  class ArchiveRoom extends Phaser.Scene{
    constructor(){ super('ArchiveRoom'); }
    create(){
      const w=this.scale.width, h=this.scale.height;
      this.cameras.main.setBackgroundColor('#07121a');
      this.add.text(20,20,'Salle des archives : Fragment Qingming', {fontSize:'18px'});

      const item = DIALOGUES.qingming;
      const container = this.add.container(w/2, h/2 - 40);
      // 替换为缩略图显示
      const img = this.add.image(0, -10, 'qingming_thumb').setOrigin(0.5,0.5);
      img.setScale(0.32); // 根据缩略图大小调整
      container.add(img);

      const label = this.add.text(0,100,item.title,{fontSize:'16px'}).setOrigin(0.5);
      container.add(label);

      // 调整 container 交互区域，保持原有交互逻辑
      container.setSize(img.displayWidth, img.displayHeight + 40);
      container.setInteractive(
               Phaser.Geom.Rectangle.Contains
      );

      // Background rectangle inside container
      const rect = this.add.rectangle(0, 0, 100, 10, 0xFFFFFF).setOrigin(0.5);
      container.add(rect);

      container.setSize(320,200);
      container.setInteractive(new Phaser.Geom.Rectangle(-160,-100,320,200), Phaser.Geom.Rectangle.Contains);
      container.on('pointerup',()=> this.openArchive(item));
      container.on('pointerover',()=> rect.setFillStyle(0x3f7b8d));
      container.on('pointerout',()=> rect.setFillStyle(0x325b6e));
      container.on('pointerover',()=> img.setTint(0xaaaaaa));
      container.on('pointerout',()=> img.clearTint());


      this.add.text(300,h-300,'Décryptage : Puzzle 15×1 →',{fontSize:'16px',backgroundColor:'#222',padding:8}).setInteractive().on('pointerup',()=>this.scene.launch('Puzzle'));

      this.choiceText = this.add.text(w-320,20,'Choix : —',{fontSize:'14px'});
      this.add.text(600,h-295, "MetadataScene", {
    fontSize: "24px",
    color: "#0077ff"
})
.setInteractive()
.on('pointerdown', () => {
    this.scene.start("MetadataScene");
});

    }

    openArchive(item){
      const w=this.scale.width, h=this.scale.height;
      const bg=this.add.rectangle(w/2,h/2, w*0.8, h*0.6, 0x000000,0.92);
      const box=this.add.container(0,0,[bg]);
      const title=this.add.text(w/2,h/2-170,item.title,{fontSize:'22px'}).setOrigin(0.5);
      const text=this.add.text(w/2-(w*0.8)/2+24,h/2-120,item.text,{fontSize:'16px',wordWrap:{width:w*0.8-48}});
      // 三个操作按钮已移除，改为单一关闭按钮以避免影响其他场景逻辑
      const closeBtn = this.add.text(w/2, h/2+160, 'FERMER', { fontSize: '16px', backgroundColor: '#555', padding: 8 }).setInteractive().setOrigin(0.5);
      box.add([title, text, closeBtn]);
      const close = () => { box.destroy(true); };
      closeBtn.on('pointerup', close);
    }

    updateChoices(){
      this.choiceText.setText('Choix : '+gameState.choices.map(c=>c.action).join(', '));
    }
  }

class Puzzle extends Phaser.Scene {
  constructor() {
    super('Puzzle');
  }

  create() {
    const w = this.scale.width;
    const h = this.scale.height;

    this.cameras.main.setBackgroundColor('#06121b');
    this.add.text(20, 20, 'Puzzle Qingming (15 × 1)', { fontSize: '18px' });

    const grid = 15;
    const displayH = 140;

    // 原图尺寸
    const src = this.textures.get('qingming_main').getSourceImage();
    const imgW = src.width;
    const imgH = src.height;

    const sliceW = Math.floor(imgW / grid);
    const scale = displayH / imgH;

    const totalW = sliceW * scale * grid;
    const startX = w / 2 - totalW / 2 + sliceW * scale / 2;
    const y = h / 2;

    // 正确顺序数组
    this.solution = Array.from({ length: grid }, (_, i) => i);

    // 槽位数组
    this.slots = [];
    for (let i = 0; i < grid; i++) {
      const xSlot = startX + i * sliceW * scale;
      this.slots.push({ x: xSlot, y: y, index: i });
    }

    // 创建碎片
    const order = Phaser.Utils.Array.Shuffle(this.solution.slice());
    this.slices = [];

    for (let i = 0; i < grid; i++) {
      const correctIndex = i;         // 正确位置
      const currentIndex = order[i];  // 初始随机位置
      const slot = this.slots[currentIndex];

      const container = this.add.container(slot.x, slot.y);
      container.correctIndex = correctIndex;
      container.currentSlot = currentIndex;

      // 图片
      const piece = this.add.image(0, 0, 'qingming_main')
        .setOrigin(0.5)
        .setScale(scale)
        .setCrop(correctIndex * sliceW, 0, sliceW, imgH);

      // 边框
      const border = this.add.rectangle(0, 0, sliceW * scale, displayH)
        .setStrokeStyle(2, 0x333333);

      container.add([piece, border]);
      container.piece = piece;
      container.border = border;

      // 更新方法
      container.updatePosition = () => {
        const s = this.slots[container.currentSlot];
        container.x = s.x;
        container.y = s.y;
      };

      container.setSize(sliceW * scale, displayH);
      container.setInteractive();
      this.input.setDraggable(container);

      this.slices.push(container);
    }

    // 拖拽逻辑
    this.input.on('dragstart', (_, container) => {
      container.border.setStrokeStyle(3, 0xffe082);
      this.children.bringToTop(container);
    });

    this.input.on('drag', (_, container, dragX, dragY) => {
      container.x = dragX;
      container.y = dragY;
    });

    this.input.on('dragend', (_, container) => {
      // 找最近槽位
      let closestSlot = null;
      let minDist = Infinity;
      this.slots.forEach(slot => {
        const d = Phaser.Math.Distance.Between(container.x, container.y, slot.x, slot.y);
        if (d < minDist) {
          minDist = d;
          closestSlot = slot;
        }
      });

      if (!closestSlot) return;

      // 判断槽位是否被占用
      const target = this.slices.find(c => c !== container && c.currentSlot === closestSlot.index);

      if (target) {
        // 交换槽位
        const tmp = container.currentSlot;
        container.currentSlot = target.currentSlot;
        target.currentSlot = tmp;

        container.updatePosition();
        target.updatePosition();
      } else {
        // 空位 → 直接占用
        container.currentSlot = closestSlot.index;
        container.updatePosition();
      }

      container.border.setStrokeStyle(2, 0x333333);

      if (this.isSolved()) this.showSuccess();
    });

    // 状态文字
    this.status = this.add.text(w / 2, y + displayH + 30,
      '拖动碎片还原卷轴…', { fontSize: '16px' })
      .setOrigin(0.5);
  }

  isSolved() {
    return this.slices.every(c => c.currentSlot === c.correctIndex);
  }

  showSuccess() {
    this.status.setText('Puzzle résolu ! 卷轴已还原');
  }
}


  class MetadataScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MetadataScene' });
    }

    create() {
        // 背景
        this.cameras.main.setBackgroundColor('#ffffff');


        // 错误元数据
        const lines = [
                { 
        text: "1. Ce rouleau a été peint en l’an 800, durant la dynastie Song du Nord.", 
        wrong: true  // 实创作于12世纪
    },
    { 
        text: "2. L’œuvre utilise une technique de coloration typique de la dynastie Ming.", 
        wrong: true  // 明代设色技法不是张择端版本
    },
    { 
        text: "3. « Le long de la rivière pendant la fête de Qingming » représente la capitale Bianjing (aujourd’hui Kaifeng) en pleine effervescence durant la fête de Qingming.", 
        wrong: false // 这是正确描述
    },
    { 
        text: "4. Ce rouleau fait partie des dix peintures les plus célèbres de l’histoire chinoise.", 
        wrong: false  // 说法流行但不属于官方“十大”
    },
    { 
        text: "5. Le début du rouleau montre les faubourgs, la partie centrale se concentre sur le pont en arc, et la fin décrit les rues animées de la ville.", 
        wrong: false  //  正确描述
    },
    { 
        text: "6. Le rouleau montre plus de cinq types de moyens de transport.", 
        wrong: false  // 正确描述
    },
    { 
        text: "7. Le rouleau représente moins de dix catégories sociales parmi les personnages.", 
        wrong: true  // 实际人物身份种类非常多
    }
];


        this.selected = 0;
        this.totalWrong = lines.filter(l => l.wrong).length;

        const startY = 120;
        const gap = 50;

        lines.forEach((line, i) => {
            let textObj = this.add.text(60, startY + i * gap, line.text, {
                fontSize: '20px',
                color: '#000'
            }).setInteractive();

            // 点击事件
            textObj.on('pointerdown', () => {
                if (line.wrong) {
                    textObj.setColor('#d60000'); // 红色表示选对了（错误句子）
                    this.selected++;  // 只在选对时计数
                } else {
                    textObj.setColor('#00a000'); // 绿色表示误选
                }

                textObj.disableInteractive();
              ;

                if (this.selected === this.totalWrong) {
                    this.showResult();
                }
            });
        });

        // 返回按钮
        this.add.text(20, 20, "← Retour", {
            fontSize: '24px',
            color: '#0077ff'
        })
        .setInteractive()
        .on('pointerdown', () => {
            this.scene.start("Puzzle");
        });
    }

       showResult() {
        const w = this.scale.width;
        const h = this.scale.height;
        
        // 背景半透明遮罩
        const bg = this.add.rectangle(w / 2, h / 2, w, h, 0x000000, 0.5);
        
        // 对话框背景
        const dialogBox = this.add.rectangle(w / 2, h / 2, 600, 200, 0xffffff);
        
        // 对话框标题
        const title = this.add.text(w / 2, h / 2 - 60, "Succès !", {
          fontSize: '28px',
          color: '#2e7d32',
          fontStyle: 'bold'
        }).setOrigin(0.5);
        
        // 对话框内容
        const content = this.add.text(w / 2, h / 2, "Vous avez identifié toutes\nles métadonnées erronées.", {
          fontSize: '18px',
          color: '#222',
          align: 'center'
        }).setOrigin(0.5);
        
        // 关闭按钮
        const closeBtn = this.add.text(w / 2, h / 2 + 70, "Fermer", {
          fontSize: '16px',
          color: '#fff',
          backgroundColor: '#2e7d32',
          padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();
        
        closeBtn.on('pointerdown', () => {
          bg.destroy();
          dialogBox.destroy();
          title.destroy();
          content.destroy();
          closeBtn.destroy();
        });
      }
}

// `Ending` scene 已移除 —— 如需恢复可从版本控制回退本段代码。

  const config={ type:Phaser.AUTO, parent:'game-container', width:1100, height:760, scene:[Boot,Intro,ArchiveRoom,Puzzle,MetadataScene] };
  new Phaser.Game(config);
  
  </script>
</body>
</html>
